<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>欢迎光临</title>
  
  <subtitle>多多的技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-09-09T10:51:27.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Rick Wong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于Objective-C的那些事儿:给分类(category)添加属性/关联对象 AssociatedObject</title>
    <link href="http://yoursite.com/2017/09/08/%E5%85%B3%E4%BA%8EObjective-C%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF-%E7%BB%99%E5%88%86%E7%B1%BB-category-%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7-%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1-AssociatedObject/"/>
    <id>http://yoursite.com/2017/09/08/关于Objective-C的那些事儿-给分类-category-添加属性-关联对象-AssociatedObject/</id>
    <published>2017-09-07T16:00:51.000Z</published>
    <updated>2017-09-09T10:51:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在Category中并不会生成实例变量和存取方法，需要手动实现。所以一般常使用Runtime<code>关联对象</code>为已经存在的类添加<code>属性</code>。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="引入运行时头文件"><a href="#引入运行时头文件" class="headerlink" title="引入运行时头文件"></a>引入运行时头文件</h3><pre><code>#import &lt;objc/runtime.h&gt;</code></pre><h3 id="在匿名分类或者-h中添加属性"><a href="#在匿名分类或者-h中添加属性" class="headerlink" title="在匿名分类或者.h中添加属性"></a>在匿名分类或者.h中添加属性</h3><h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><ul><li>匿名分类中添加的是私有属性，只在本类中可以使用，类的实例中不可使用。</li><li><p>.h中添加的的在类的实例中也可使用。</p><pre><code>// 分类的头文件@interface ClassName (CategoryName)//我要添加一个实例也可以访问的变量所以就写在这里了@property (nonatomic, strong) NSString *str;@end// 匿名分类@interface ClassName ()@end</code></pre></li><li><p>在实现里面写要添加属性的getter、setter方法</p><pre><code>@implementation ClassName (CategoryName) -(void)setStr:(NSString *)str  {      objc_setAssociatedObject(self, &amp;strKey, str, OBJC_ASSOCIATION_COPY);  }  -(NSString *)str  {      return objc_getAssociatedObject(self, &amp;strKey);  }@end</code></pre><ul><li><p>如上所示：<code>setStr:</code>方法中使用的<code>objc_setAssociatedObject</code>方法有四个参数：</p><ul><li>源对象</li><li><p>标记属性的key(关联时用来标记是哪一个属性的key)<br>常见有三种写法：</p><pre><code>// 利用静态变量地址唯一不变的特性1、static void *strKey = &amp;strKey; 使用strKey作为key值；2、static NSString *strKey = @&quot;strKey&quot;; 或者 static char strKey; 使用&amp;strKey作为key值；3、用selector，使用getter方法的名称作为key值。【推荐使用】</code></pre></li><li><p>关联对象<br><code>runtime</code>提供的方法如下：</p><pre><code>  // 关联对象void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)// 获取关联的对象id objc_getAssociatedObject(id object, const void *key)// 移除关联的对象void objc_removeAssociatedObjects(id object)    </code></pre><p>  变量说明：</p><pre><code>id object：被关联的对象const void *key：关联的key，要求唯一id value：关联的对象objc_AssociationPolicy policy：内存管理的策略</code></pre></li><li><p>关联策略<br>关联策略(<code>objc_AssociationPolicy</code>)指的是枚举值，policy的enum值包含以下几种</p><pre><code>enum {OBJC_ASSOCIATION_ASSIGN = 0, //关联对象的属性是弱引用 OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, //关联对象的属性是强引用并且关联对象不使用原子性OBJC_ASSOCIATION_COPY_NONATOMIC = 3, //关联对象的属性是copy并且关联对象不使用原子性OBJC_ASSOCIATION_RETAIN = 01401, //关联对象的属性是copy并且关联对象使用原子性    OBJC_ASSOCIATION_COPY = 01403 //关联对象的属性是copy并且关联对象使用原子性};当对象被释放时，会根据此策略决定是否释放关联的对象。</code></pre></li></ul></li></ul></li></ul><h1 id="关联对象的内存管理"><a href="#关联对象的内存管理" class="headerlink" title="关联对象的内存管理"></a>关联对象的内存管理</h1><ul><li>关联对象的释放实际与移除时机并不总是一致，如果使用关联策略<code>OBJC_ASSOCIATION_ASSIGN</code>进行关联对像即便释放，其在内存中也不会移除，如果在使用此关联对象时会crash。</li><li>关联对象与被关联对象本身的存储并无直接关系，它是存储在单独的哈希表中。</li><li>管理对象的五种关联策略与属性的限定符非常类似，多数情况下会使用<code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code>的管理策略，可保证持有关联对象。</li><li>关联对象释放时机：<br>  一个对象的所有关联对象是在此对象被释放时调用<code>_object_remove_assocations</code>函数中被移除的。</li></ul><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><pre><code>Associated Objects的三个主要使用场景：</code></pre><ul><li>为现有的类添加私有变量以帮助实现细节；</li><li>为现有的类添加公有属性；</li><li><p>为KVO创建一个关联的观察者。<br>有时在分类中使用KVO，推荐使用关联的对象作为观察者，尽量避免对象观察自身。</p><h1 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h1><p>在<code>runtime</code>源码中可以找到如下三个与<code>Associated Objects</code>相关的三个函数:</p><pre><code>void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);void objc_getAssociatedObject(id object, const void *key);void objc_removeAssociatedObjects(id object);</code></pre></li><li><p>objc_setAssociatedObject 用于给对象添加关联对象，传入nil则可以移除已有的关联对象；</p></li><li>objc_getAssociatedObject 用于获取关联对象；</li><li>objc_removeAssociatedObjects 用于移除一个对象的所有关联对象。</li></ul><p><code>objc_removeAssociatedObjects</code> 函数我们一般用不上，因为它会移除一个对象的所有关联对象，将该对象恢复”原始”状态。这样会把别人添加的关联对象也一并移除。<br>因此会选择通过给 <code>objc_setAssociatedObject</code> 函数传入ni来移除某个已有的关联对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在Category中并不会生成实例变量和存取方法，需要手动实现。所以一般常使用Runtime&lt;code&gt;关联对象&lt;/code&gt;为已经存在的类
      
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>关于Objective-C的那些事儿:Category(分类,类别)</title>
    <link href="http://yoursite.com/2017/09/06/%E5%85%B3%E4%BA%8EObjective-C%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF-Category-%E5%88%86%E7%B1%BB-%E7%B1%BB%E5%88%AB/"/>
    <id>http://yoursite.com/2017/09/06/关于Objective-C的那些事儿-Category-分类-类别/</id>
    <published>2017-09-06T12:02:00.000Z</published>
    <updated>2017-09-09T11:20:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><code>Category</code>是<code>OC</code>中特有的方法，（在<code>java</code>中不存在）分类只是用来扩展类时不需要继承关系那么复杂，特殊的语法处理特殊的问题，语法就是如此发展而来。</p><pre><code>、、、objectivec    // 声明@interface 类名(分类名称)@end// 实现@implementation 类名（分类名称）@end、、、</code></pre><ul><li><p>分类只是用来扩展类时不需要继承关系那么麻烦。如果使用继承关系扩充一个类，有一个弊病(面向对象弊病)：</p><ul><li>高耦合性:只要父类稍作改变，子类就会受到严重影响，甚至导致子类不可用，给开发带来困难。</li></ul></li></ul><h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><p>把不同的功能写在不同的类中去，并且命名；分类模块一般以功能命名，而不是以作者命名。</p><ul><li>凡是要扩充一些工具方法，优先考虑分类，如果没有发现合适的类扩充，则在新建类。</li><li>开发中经常要写一些分类，把有价值方法抽出来，方便拓展使用<ul><li>水印功能比较好用，可抽出来，以后使用</li><li>可经常打造自己的分类，积累越多，以后开发越轻松，打造自己的<code>类库</code> <code>框架</code>供调用，即造轮子。</li></ul></li></ul><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul><li>在分类中可调用原类的方法，也可访问原类的成员变量</li><li>原类声明的成员变量，可在分类中直接访问</li><li>不能在分类中声明成员变量</li><li>如果在分类中定义且实现了原类中相同的方法，则原类中的方法会被覆盖，应当避免</li></ul><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p><code>Category</code>可以给某一个类扩充一些方法（不修改原来类的代码），但是不可以扩充成员变量（通过关联可以，详见：<a href="http://wangmasterpro.com/2017/09/08/关于Objective-C的那些事儿-给分类-category-添加属性-关联对象-AssociatedObject/" target="_blank" rel="external">关于Objective-C的那些事儿:给分类(category)添加属性/关联对象 AssociatedObject</a>）。</p><h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><ul><li><p>分类只能增加方法，不能增加成员变量；如果想增加变量，可以考虑通过集成创建子类，或者穿件关联也可。</p></li><li><p>分类方法实现中可访问原来类中声明的成员变量；</p></li><li><p>分类方法优先级最高：分类可重新实现原来类中方法，但会覆盖掉原来的方法，导致原来方法无法使用。</p><ul><li>调用顺序：优先去分类中查找，然后再去原来类中找，最后去父类中找。分类(最后参与编译的分类优先) -&gt; 原来类 -》 父类</li></ul></li><li><p>多个分类中如果实现了相同的方法，只有最后一个参与编译的才有效。</p></li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>适合团队开发。</p><ul><li><p>一个庞大的类可以分模块开发；</p></li><li><p>一个庞大的类可以由多个人来编写，利于团队合作。</p></li></ul><h2 id="分类协议"><a href="#分类协议" class="headerlink" title="分类协议"></a>分类协议</h2><p>分类协议可以定义在单独的.h和.m文件中，也可定义在原来类中。</p><ul><li>一般都是单独定义在单独文件中</li><li>也可定义在原来类中。(分类大部分情况都是单独文件，很少写在原来类里面)</li></ul><p>OC语法：冒号继承，尖号遵守协议，括号分类；</p><h2 id="Category和Extension"><a href="#Category和Extension" class="headerlink" title="Category和Extension"></a>Category和Extension</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><code>Extension</code>是<code>Category</code>的一个特例，其名字为匿名<br><code>extension</code>在编译器处理，是类的一部分，随类的生命周期变化。<br>一般用来隐藏类的私有信息，不被外界访问，须有类的源码才能为一个类添加<code>extension</code>，因此无法为系统的类如<code>NSSArray</code>添加<code>extension</code>。</p><h3 id="二者比较"><a href="#二者比较" class="headerlink" title="二者比较"></a>二者比较</h3><ul><li>相同点：都可为一个类添加方法</li><li><p>区别：</p><ul><li><code>Category</code>在定义方法不实现，编译器不会报错，运行调用时出错；Extensions在实现中不实现编译器会警告。</li><li><code>Category</code>只能用于添加方法，不能用于添加成员变量（运行时添加关联对象也可添加）。<code>extension</code>中声明的方法和添加的成员变量是私有的，只有主实现能调用，外部类无法调用。</li><li><code>Category</code>增加方法如果与类方法同名会被覆盖，因为<code>Category</code>优先级高，而<code>Extension</code>则会报错。</li></ul></li></ul><h2 id="Category如何加载"><a href="#Category如何加载" class="headerlink" title="Category如何加载"></a>Category如何加载</h2><p>如果在分类中实现了原类的方法，如<code>methodA</code>，需要注意：</p><ul><li><code>category</code>的方法没有‘完全替换掉’原类已有的方法，即<code>Category</code>和原类都会有<code>methodA</code>，<code>Category</code>加载完成后，类的方法列表里会有两个<code>methodA</code>。</li><li><code>category</code>的方法被放到了新方法列表的前面，而原类的方法被放到了新方法列表的后面。因为运行时查找方法时是顺着方法列表的顺序查找的，只要找到对应名字的方法就会停止查找。</li></ul><h2 id="Category和-load方法"><a href="#Category和-load方法" class="headerlink" title="Category和+load方法"></a>Category和+load方法</h2><p>如果在原类和其<code>Category</code>中都有<code>load</code>方法时：</p><ul><li>在原类的<code>+load</code>方法调用时，可以调用<code>Category</code>中声明的方法吗？<br>可以调用，<code>Category</code>到原来类的附加工作会先与<code>+load</code>方法的执行。</li><li><p>其调用顺序是怎么样的？<br><code>+load</code>方法的执行顺序：先本类，后<code>Category</code>，而<code>Category</code>的<code>+load</code>执行顺序是根据编译顺序决定的。</p><p>  <code>PS</code>:编译顺序是根据<code>Xcode</code>的<code>Build Setting</code>中的<code>Compile Sources</code>中的类顺序决定。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Category&lt;/code&gt;是&lt;code&gt;OC&lt;/code&gt;中特有的方法，（在&lt;code&gt;java&lt;/code&gt;中不存在）分类
      
    
    </summary>
    
      <category term="Objective-C" scheme="http://yoursite.com/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS悬浮按钮的实现</title>
    <link href="http://yoursite.com/2016/10/29/iOS%E6%82%AC%E6%B5%AE%E6%8C%89%E9%92%AE%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2016/10/29/iOS悬浮按钮的实现/</id>
    <published>2016-10-29T15:18:52.000Z</published>
    <updated>2017-09-09T11:22:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><p>项目中为了实现“新手礼包”悬浮按钮需求：悬浮按钮在项目当中若干页面出现，且按钮不随着页面的上下和左右滑动而改变位置。<a id="more"></a></p><h3 id="悬浮按钮实现效果图："><a href="#悬浮按钮实现效果图：" class="headerlink" title="悬浮按钮实现效果图："></a>悬浮按钮实现效果图：</h3><p><img src="/images/DriftButton_Global1.gif" alt="DriftButton_Global1"> <img src="/images/DriftButton_Global2.gif" alt="DriftButton_Global2"></p><p>-》页面垂直滑动时按钮位置不动：</p><p><img src="/images/DriftButton_Global3.gif" alt="DriftButton_Global3"></p><h3 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h3><font size="3"><strong>一、自定义悬浮按钮，并将按钮置于程序窗口之上【单例】</strong></font><p>RWDriftButton.h</p><pre><code><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWDriftButton</span> : <span class="title">UIButton</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^clickHandler)(); <span class="comment">// 悬浮按钮的点击回调</span></div><div class="line">+ (<span class="keyword">instancetype</span>)shareInstance;</div><div class="line"><span class="keyword">@end</span>;</div></pre></td></tr></table></figure></code></pre><p>RWDriftButton.m</p><pre><code><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWDriftButton.h"</span></span></div><div class="line"></div><div class="line"><span class="comment">// 大于iOS8以上</span></div><div class="line"><span class="meta">#define QRIOS8Later                ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;=8.0 ?  YES : NO)</span></div><div class="line"><span class="comment">// 屏幕宽</span></div><div class="line"><span class="meta">#define QRMainW (!QRIOS8Later?[UIScreen mainScreen].bounds.size.width:[[[UIScreen mainScreen] fixedCoordinateSpace] bounds].size.width)</span></div><div class="line"><span class="comment">// 屏幕高</span></div><div class="line"><span class="meta">#define QRMainH (!QRIOS8Later?[UIScreen mainScreen].bounds.size.height:[[[UIScreen mainScreen] fixedCoordinateSpace] bounds].size.height)</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RWDriftButton</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)shareInstance &#123;</div><div class="line">   <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">   <span class="keyword">static</span> RWDriftButton *DriftButton;</div><div class="line">   <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">       DriftButton = [RWDriftButton buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</div><div class="line">       <span class="built_in">CGFloat</span> DriftBottom = <span class="number">8</span>;</div><div class="line">       <span class="built_in">CGFloat</span> DriftRight  = <span class="number">8</span>;    <span class="comment">// 礼包右边距</span></div><div class="line">       <span class="built_in">CGFloat</span> DriftBtnW   = <span class="number">42</span>;   <span class="comment">// 礼包宽度</span></div><div class="line">       <span class="built_in">CGFloat</span> DriftBtnH   = <span class="number">42</span>;   <span class="comment">// 礼包高度</span></div><div class="line">       <span class="built_in">CGFloat</span> TarbarHight = <span class="number">49</span>;   <span class="comment">// 导航控制器底部tarbar高度</span></div><div class="line">       <span class="built_in">CGFloat</span> DriftButtonX = QRMainW - DriftRight - DriftBtnW;</div><div class="line">       <span class="built_in">CGFloat</span> DriftButtonY = QRMainH - DriftBottom - DriftBtnW;</div><div class="line">       DriftButton.frame = <span class="built_in">CGRectMake</span>(DriftButtonX, DriftButtonY - TarbarHight, DriftBtnW, DriftBtnH);</div><div class="line">       DriftButton.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</div><div class="line">       DriftButton.layer.cornerRadius = DriftBtnW * <span class="number">0.5</span>;</div><div class="line">       [DriftButton addTarget:DriftButton action:<span class="keyword">@selector</span>(click:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line">   &#125;);</div><div class="line">   <span class="keyword">return</span> DriftButton;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  点击礼包Block回调</div><div class="line"> *</div><div class="line">*  @param sender </div><div class="line">*/</div><div class="line">- (<span class="keyword">void</span>)click:(<span class="keyword">id</span>)sender</div><div class="line">&#123;</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">self</span>.clickHandler) &#123;</div><div class="line">      <span class="keyword">self</span>.clickHandler();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></code></pre><font size="3"><strong>二、RWBaseViewController为项目中已有的基类，在基类中设置单例悬浮按钮隐藏</strong></font><p>RWBaseViewController.m：</p><pre><code><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  /*项目中所有页面的基类*/</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"RWBaseViewController.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWBaseViewController</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RWBaseViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">   [<span class="keyword">super</span> viewDidLoad];</div><div class="line">   <span class="comment">// Do any additional setup after loading the view.、</span></div><div class="line">   </div><div class="line">   [RWDriftButton shareInstance].hidden = <span class="literal">YES</span>; <span class="comment">// 基类不需要显示，子类如果需要显示悬浮按钮，设置hidden为NO即可；</span></div><div class="line">   </div><div class="line">   <span class="keyword">self</span>.navigationItem.title = <span class="string">@"基类页面[不显示悬浮按钮]"</span>;</div><div class="line">   <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> grayColor];</div><div class="line">&#125;</div></pre></td></tr></table></figure></code></pre><font size="3"><strong>三、RWDriftViewController为项目中的浮层类，根据需求在浮层类中的声明周期方法中设置悬浮按钮的显示以及显示效果</strong></font><p>RWDriftViewController.m：</p><pre><code><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"RWDriftViewController.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"RWBaseViewController.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"RWDriftButton.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWDriftViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) RWDriftButton *DriftButton;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RWDriftViewController</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">   [<span class="keyword">super</span> viewDidLoad];</div><div class="line">   <span class="comment">// Do any additional setup after loading the view.</span></div><div class="line">   <span class="keyword">self</span>.navigationItem.title = <span class="string">@"悬浮类[继承自悬浮类的页面可显示悬浮按钮]"</span>;</div><div class="line">   <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> brownColor];</div><div class="line">   <span class="keyword">if</span> (![RWDriftButton shareInstance].superview) &#123;</div><div class="line">       [[<span class="built_in">UIApplication</span> sharedApplication].keyWindow addSubview:[RWDriftButton shareInstance]];</div><div class="line">   &#125;</div><div class="line">   [[<span class="built_in">UIApplication</span> sharedApplication].keyWindow bringSubviewToFront:[RWDriftButton shareInstance]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">   [<span class="keyword">super</span> viewWillAppear:<span class="literal">YES</span>];</div><div class="line">   [RWDriftButton shareInstance].hidden = <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">   [<span class="keyword">super</span> viewDidAppear:<span class="literal">YES</span>];</div><div class="line">[RWDriftButton shareInstance].hidden = <span class="literal">NO</span>;</div><div class="line">   [[RWDriftButton shareInstance] setClickHandler:^&#123;</div><div class="line">       RWBaseViewController *RWBaseVc = [RWBaseViewController new];</div><div class="line">       [<span class="keyword">self</span>.navigationController pushViewController:RWBaseVc animated:<span class="literal">YES</span>];</div><div class="line">   &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">   [<span class="keyword">super</span> viewWillDisappear:<span class="literal">YES</span>];</div><div class="line">   [RWDriftButton shareInstance].hidden = <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></code></pre><h3 id="如上，满足业务各种需求的悬浮按钮—全局-就完美实现了。在使用过程中如果需求有差异可稍加改动即可。"><a href="#如上，满足业务各种需求的悬浮按钮—全局-就完美实现了。在使用过程中如果需求有差异可稍加改动即可。" class="headerlink" title="如上，满足业务各种需求的悬浮按钮—全局 就完美实现了。在使用过程中如果需求有差异可稍加改动即可。"></a>如上，满足业务各种需求的悬浮按钮—全局 就完美实现了。在使用过程中如果需求有差异可稍加改动即可。</h3><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a><a href="https://github.com/WangMasterpro/DriftButton_Global" title="Demo" target="_blank" rel="external"><font color="Red">Demo</font></a></h3><p><a href="https://github.com/WangMasterpro/DriftButton_Global" target="_blank" rel="external">iOS全局悬浮按钮</a></p><h5 id="如各位喜欢博文的烦请各位点个赞，如有帮到大家请在github上给demo个star，如有问题可在博客下方留言，我会及时回复哒"><a href="#如各位喜欢博文的烦请各位点个赞，如有帮到大家请在github上给demo个star，如有问题可在博客下方留言，我会及时回复哒" class="headerlink" title=" 如各位喜欢博文的烦请各位点个赞，如有帮到大家请在github上给demo个star，如有问题可在博客下方留言，我会及时回复哒"></a><font color="Green"> 如各位喜欢博文的烦请各位点个赞，如有帮到大家请在github上给demo个star，如有问题可在博客下方留言，我会及时回复哒</font></h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求描述&quot;&gt;&lt;a href=&quot;#需求描述&quot; class=&quot;headerlink&quot; title=&quot;需求描述&quot;&gt;&lt;/a&gt;需求描述&lt;/h2&gt;&lt;p&gt;项目中为了实现“新手礼包”悬浮按钮需求：悬浮按钮在项目当中若干页面出现，且按钮不随着页面的上下和左右滑动而改变位置。
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
